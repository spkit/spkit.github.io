
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/signal_processing/plot_sp_ATAR_algorithm_eeg_artifact_removal.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_signal_processing_plot_sp_ATAR_algorithm_eeg_artifact_removal.py>`
        to download the full example code or to run this example in your browser via JupyterLite or Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_signal_processing_plot_sp_ATAR_algorithm_eeg_artifact_removal.py:


======================================================
ATAR: Automatic and Tunable Artifact Removal Algorithm
======================================================


ATAR: Automatic and Tunable Artifact Removal Algorithm
<div class="toc"><ul class="toc-item"><li><span><a href="#ATAR:-Automatic-and-Tunable-Artifact-Removal-Algorithm" data-toc-modified-id="ATAR:-Automatic-and-Tunable-Artifact-Removal-Algorithm-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>ATAR: Automatic and Tunable Artifact Removal Algorithm</a></span></li><li><span><a href="#Import-EEG-sample-data" data-toc-modified-id="Import-EEG-sample-data-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Import EEG sample data</a></span><ul class="toc-item"><li><span><a href="#Filter-with-highpass" data-toc-modified-id="Filter-with-highpass-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>Filter with highpass</a></span></li></ul></li><li><span><a href="#Applying-ATAR-Algorithm" data-toc-modified-id="Applying-ATAR-Algorithm-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Applying ATAR Algorithm</a></span><ul class="toc-item"><li><span><a href="#Soft-Thresholding:-default-settings:-OptMode='soft'-and-$\beta=0.1$" data-toc-modified-id="Soft-Thresholding:-default-settings:-OptMode='soft'-and-$\beta=0.1$-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>Soft Thresholding: default settings: OptMode='soft' and $\beta=0.1$</a></span></li><li><span><a href="#Linear-Attenuation" data-toc-modified-id="Linear-Attenuation-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>Linear Attenuation</a></span></li><li><span><a href="#Elimination" data-toc-modified-id="Elimination-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>Elimination</a></span></li><li><span><a href="#Tuning-$\beta$-with-'soft'-:-Controlling-the-aggressiveness" data-toc-modified-id="Tuning-$\beta$-with-'soft'-:-Controlling-the-aggressiveness-3.4"><span class="toc-item-num">3.4&nbsp;&nbsp;</span>Tuning $\beta$ with 'soft' : Controlling the aggressiveness</a></span></li><li><span><a href="#Tuning-$\beta$-with-'elim'" data-toc-modified-id="Tuning-$\beta$-with-'elim'-3.5"><span class="toc-item-num">3.5&nbsp;&nbsp;</span>Tuning $\beta$ with 'elim'</a></span></li></ul></li><li><span><a href="#Other-settings" data-toc-modified-id="Other-settings-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>Other settings</a></span><ul class="toc-item"><li><span><a href="#Changing-wavelet-function" data-toc-modified-id="Changing-wavelet-function-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>Changing wavelet function</a></span></li><li><span><a href="#Changing-upper-and-lower-bounds:-$k_1$,-$k_2$" data-toc-modified-id="Changing-upper-and-lower-bounds:-$k_1$,-$k_2$-4.2"><span class="toc-item-num">4.2&nbsp;&nbsp;</span>Changing upper and lower bounds: $k_1$, $k_2$</a></span></li><li><span><a href="#Changing-IPR----Interpercentile-range" data-toc-modified-id="Changing-IPR----Interpercentile-range-4.3"><span class="toc-item-num">4.3&nbsp;&nbsp;</span>Changing IPR -  Interpercentile range</a></span></li><li><span><a href="#Using-the-fix-threshold-$\theta_\alpha=300$,--to-all-the-windows" data-toc-modified-id="Using-the-fix-threshold-$\theta_\alpha=300$,--to-all-the-windows-4.4"><span class="toc-item-num">4.4&nbsp;&nbsp;</span>Using the fix threshold $\theta_\alpha=300$,  to all the windows</a></span></li><li><span><a href="#Changing-window-length-(5-sec)" data-toc-modified-id="Changing-window-length-(5-sec)-4.5"><span class="toc-item-num">4.5&nbsp;&nbsp;</span>Changing window length (5 sec)</a></span></li></ul></li><li><span><a href="#Doc" data-toc-modified-id="Doc-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>Doc</a></span></li></ul></div>

ATAR: Automatic and Tunable Artifact Removal Algorithm

**ATAR Algorithm -  Automatic and Tunable Artifact Removal Algorithm for EEG Signal.** 

The algorithm is based on wavelet packet decomposion (WPD), the full description of algorithm can be found here [Automatic and Tunable Artifact Removal Algorithm for EEG](https://doi.org/10.1016/j.bspc.2019.101624) from the article [1]. Figure 1 shows the the block diagram and operating mode of filtering.

<div style="align: left; text-align:center;">
    <img src="https://raw.githubusercontent.com/spkit/spkit.github.io/master/assets/images/ATAR_BD_FilteringMode_1.png" width="800" />
    <div class="caption">Fig 1: ATAR Algorithm Block Diagram and Mode of filtering</div>
</div>


The algorithm is applied on the given multichannel signal X (n,nch), window wise and reconstructed with overall add method. The defualt window size is set to 1 sec (128 samples). For each window, the threshold $\theta_\alpha$ is computed and applied to filter the wavelet coefficients.

There is manily one parameter that can be tuned $\beta$ with different operating modes and other settings.
Here is the list of parameters and there simplified meaning given:

Parameters:
* $\beta$: This is a main parameter to tune, highher the value, more aggressive the algorithm to remove the artifacts. By default it is set to 0.1. $\beta$ is postive float value.

* ***OptMode***: This sets the mode of operation, which decides hoe to remove the artifact. By default it is set to 'soft', which means Soft Thresholding, in this mode, rather than removing the pressumed artifact, it is suppressed to the threshold, softly. OptMode='linAtten', suppresses the pressumed artifact depending on how far it is from threshold. Finally, the most common mode - Elimination (OptMode='elim'), which remove the pressumed artifact.

    * Soft Thresholding and Linear Attenuation require addition parameters to set the associated thresholds which are by default set to bf=2, gf=0.8. 

* ***wv=db3***: Wavelet funtion, by default set to db3, could be any of ['db3'.....'db38', 'sym2.....sym20', 'coif1.....coif17', 'bior1.1....bior6.8', 'rbio1.1...rbio6.8', 'dmey']

* $k_1$, $k_2$: Lower and upper bounds on threshold $\theta_\alpha$.
* ***IPR=[25,75]***: interpercentile range, range used to compute threshold

Figure 2, below, shows the affect of $\beta$ on a segment of signal with three different modes.

<div style="align: left; text-align:center;">
    <img src="https://raw.githubusercontent.com/Nikeshbajaj/spkit/master/figures/atar_beta_tune.gif" width="500" />
    <div class="caption">Fig 1: ATAR Algorithm with three mode of filtering</div>
</div>



**Reference**
* [1] Bajaj, Nikesh, et al. "Automatic and tunable algorithm for EEG artifact removal using wavelet decomposition with applications in predictive modeling during auditory tasks." Biomedical Signal Processing and Control 55 (2020): 101624.

There are three functions in **spkit.eeg** for **ATAR algorithm**

* **spkit.eeg.ATAR(...)**
* spkit.eeg.ATAR_1Ch(...)
* spkit.eeg.ATAR_mCh(...)
* spkit.eeg.ATAR_mCh_noParallel(...)

***spkit.eeg.ATAR_1Ch*** is for single channel input signal x of shape (n,), where as, ***spkit.eeg.ATAR_mCh*** is for multichannel signal X with shape (n,ch), which uses joblib for parallel processing of multi channels. For some OS, joblib raise an error of ***BrokenProcessPool***, in that case use  ***spkit.eeg.ATAR_mCh_noParallel***, which is same as ***spkit.eeg.ATAR_mCh***, except parallel processing. Alternatively, use ***spkit.eeg.ATAR_1Ch*** with for loop for each channel.

***spkit.eeg.ATAR*** is generalized function, this will call ***spkit.eeg.ATAR_1Ch*** is single channel is passed else ***spkit.eeg.ATAR_mCh*** and with *use_joblib* agrument, it can be set to try parallel processing, else will process each channel individually. We recommed to use ***spkit.eeg.ATAR***.

.. GENERATED FROM PYTHON SOURCE LINES 62-453



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_001.png
         :alt: Xf: 14 channel - EEG Signal (filtered)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_002.png
         :alt: XR: Corrected Signal
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_003.png
         :alt: Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_004.png
         :alt: XR: Corrected Signal
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_005.png
         :alt: Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_006.png
         :alt: XR: Corrected Signal
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_006.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_007.png
         :alt: Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_007.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_008.png
         :alt: XR: Corrected Signal: $\beta=$0.01, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_008.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_009.png
         :alt: XR: Corrected Signal: $\beta=$0.03, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_009.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_010.png
         :alt: XR: Corrected Signal: $\beta=$0.05, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_010.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_011.png
         :alt: XR: Corrected Signal: $\beta=$0.07, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_011.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_012.png
         :alt: XR: Corrected Signal: $\beta=$0.09, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_012.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_013.png
         :alt: XR: Corrected Signal: $\beta=$0.1, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_013.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_014.png
         :alt: XR: Corrected Signal: $\beta=$0.2, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_014.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_015.png
         :alt: XR: Corrected Signal: $\beta=$0.3, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_015.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_016.png
         :alt: XR: Corrected Signal: $\beta=$0.4, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_016.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_017.png
         :alt: XR: Corrected Signal: $\beta=$0.5, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_017.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_018.png
         :alt: XR: Corrected Signal: $\beta=$0.6, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_018.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_019.png
         :alt: XR: Corrected Signal: $\beta=$0.7, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_019.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_020.png
         :alt: XR: Corrected Signal: $\beta=$0.8, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_020.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_021.png
         :alt: XR: Corrected Signal: $\beta=$0.9, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_021.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_022.png
         :alt: XR: Corrected Signal: $\beta=$0.01, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_022.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_023.png
         :alt: XR: Corrected Signal: $\beta=$0.03, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_023.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_024.png
         :alt: XR: Corrected Signal: $\beta=$0.05, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_024.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_025.png
         :alt: XR: Corrected Signal: $\beta=$0.07, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_025.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_026.png
         :alt: XR: Corrected Signal: $\beta=$0.09, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_026.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_027.png
         :alt: XR: Corrected Signal: $\beta=$0.1, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_027.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_028.png
         :alt: XR: Corrected Signal: $\beta=$0.2, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_028.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_029.png
         :alt: XR: Corrected Signal: $\beta=$0.3, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_029.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_030.png
         :alt: XR: Corrected Signal: $\beta=$0.4, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_030.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_031.png
         :alt: XR: Corrected Signal: $\beta=$0.5, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_031.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_032.png
         :alt: XR: Corrected Signal: $\beta=$0.6, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_032.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_033.png
         :alt: XR: Corrected Signal: $\beta=$0.7, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_033.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_034.png
         :alt: XR: Corrected Signal: $\beta=$0.8, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_034.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_035.png
         :alt: XR: Corrected Signal: $\beta=$0.9, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_035.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_036.png
         :alt: XR: Corrected Signal: $wv=db8$, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_036.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_037.png
         :alt: XR: Corrected Signal: $wv=db32$, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_037.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_038.png
         :alt: XR: Corrected Signal: $k_2=200$, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_038.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_039.png
         :alt: XR: Corrected Signal: $IPR=[15,85]$~ 70%, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_039.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_040.png
         :alt: XR: Corrected Signal: $\theta_\alpha=300$, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_040.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_041.png
         :alt: XR: Corrected Signal: $winsize=5sec$, Xf - XR: Difference (removed signal)
         :srcset: /auto_examples/signal_processing/images/sphx_glr_plot_sp_ATAR_algorithm_eeg_artifact_removal_041.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /Users/nikeshbajaj/Library/CloudStorage/OneDrive-QueenMary,UniversityofLondon/Github/GIT3/Dev/SPKIT_Dev/SPKIT_DOC_7/examples/signal_processing/plot_sp_ATAR_algorithm_eeg_artifact_removal.py:79: DeprecationWarning: function eegSample will be deprecated in future version, due to naming convension, please use 'eeg_sample_14ch' for updated/improved functionality [spkit-0.0.9.7].
    /Users/nikeshbajaj/anaconda3/envs/SPHX/lib/python3.10/site-packages/scipy/signal/_filter_design.py:2899: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
    Help on function ATAR in module spkit.eeg.atar_algorithm:

    ATAR(X, wv='db3', winsize=128, thr_method='ipr', OptMode='soft', IPR=[25, 75], beta=0.1, k1=10, k2=100, est_wmax=100, theta_a=inf, bf=2, gf=0.8, wpd_mode='symmetric', wpd_maxlevel=None, recons_method='atar-style', window=['hamming', True], hopesize=None, packetwise=False, WPD=True, lvl=[], use_joblib=False, verbose=False, **kwargs)
        ATAR - Automatic and Tunable Artifact Removal Algorithm
    
        .. raw:: html
    
            <h2 style="text-align:center">ATAR: - Automatic and Tunable Artifact Removal Algorithm</h2>
    
        Apply ATAR on short windows of signal (single channel):
    
        Signal is decomposed in smaller overlapping windows and reconstructed after correcting using overlap-add method.
    
        For more details, check [1]_
    
        **Operating Modes**
    
        **1. Soft Thresholding**
    
        .. math ::
    
           \lambda_s (w)  &=  w  & \quad \text{if } |w|<\theta_{\gamma}
    
              &=  \theta_{\alpha} \frac{1 - e^{\alpha w}}{1 + e^{\alpha w}}   & \quad \text{otherwise}
    
    
        **2. Elimination**
    
        .. math ::
    
           \lambda_e (w)  &=  w  & \quad \text{if } |w| \le \theta_{\alpha}
    
             &=  0   & \quad \text{otherwise}
    
    
        **3. Linear Attenuation**
    
        .. math ::
    
           \lambda_a (w)  &=  w  & \quad \text{if } |w| \le \theta_{\alpha}
    
                  &=  sgn(w) \theta_{\alpha} \Big( 1 -  \frac{|w| - \theta_{\alpha}}{\theta_{\beta}-\theta_{\alpha}} \Big) & \quad \text{if } \theta_{\alpha} < |w| \le \theta_{\beta}
              
                  &=  0   & \quad \text{otherwise}
    
    
        **Computing Threshold**
    
        * :math:`f_{\beta}(r)  = k_2 \cdot exp \Big(-\beta \frac{w_{max}}{k_2} \times \frac{r}{2} \Big)`
    
        * :math:`\theta_{\alpha}  =  f_{\beta}(r)  \quad \text{if } f_{\beta}(r) \ge k_1` otherwise :math:`\theta_{\alpha}  =  k_1`
    
        * :math:`\theta_{\gamma}  = g_f \times \theta_{\alpha}` ,  where a default value for 'g_f = 0.8' **For Soft-threshold**
    
        * :math:`\theta_{\beta}  = b_f \times \theta_{\alpha}` , where a default value for 'b_f = 2' **For Linear Attenuation**
    
    
        Parameters
        ----------
        x : 1d-array
          - input single-channel signal of shape (n,)
    
        wv = str, 'db3'(default) wavelet
          - one of wavelet family {'db3'.....'db38', 'sym2.....sym20', 
                         'coif1.....coif17', 'bior1.1....bior6.8', 
                        'rbio1.1...rbio6.8', 'dmey'}
    
        winsize: int, deafult=128
           -  window size to apply ATAR
    
        hopesize: int, None, default=None,
           - overlap shift for next window
           - if None, hopesize=winsize//2
           - only used when recons_method={'atar-style','atar','custom'}
    
    
        Operating modes
    
        OptMode: str, {'soft','elim','linAtten'}, default 'soft'
            - Operating Modes:
            - soft: soft-thresholding (need theta_a, and theta_g)
            - elim: Elimination mode  (need theta_a)
            - linAtten: Linear Attenuation mode (need theta_a and theta_b)
                - given `bf` and `gf` (default bf = 2, gf=0.8)
                -  where:-
                    * theta_b = bf*theta_a  -- used for Linear Attenuation
                    * theta_g = gf*theta_a  -- used for Soft thresholding
    
        *Threshold Computation method*
    
        thr_method: str, {'ipr', None}
            - Computing method for threshold
            - if 'ipr'  'theta_a' is computed as per ATAR's approach
            - if None, passed value of 'theta_a' is used along with (bf, gf)
    
        IPR: list of two default=[25,75]
           - To compute Interpercentile range r
           - e.g. [10,90], [30,70]
           - Higher the range is, threshold is more affected by outliers
           - Interpercentile range r is mapped to threshold, using `beta`, `k1` and `k2`
    
        beta: float (0,1] default=0.1
           - beta as tuning parameter for threshold
           - higher the value, more aggressive is the algorithm to remove artifacts
    
        (k1,k2) :scalars, defualt (10,100)
           - lower and upper bounds on the threshold value
           - should be of same order as signal magnitude.
           - if signal is in volts, values will be of order 1e-6, then k1 and k2 should be around those order
           - defult values k1=10, k2=100 are chosen for signal with unit of microVolt (uV), of order of 100s
       
    
           .. warning:: k1,k2 bounds
              if k2 is very high (e.g. 100) and signal amplitude is in 1e-3, 1e-6, 
              ATAR will have no effect on the signal, as theshold to identify and remove artifacts will be so high.
    
    
        est_wmax: int, default=100
            - est_wmax is the value in the expression (15 in paper) or above Computing Threshold equations `w_max`
    
    
        *Wavelet Decomposition*
    
        wpd_mode: str,  default 'symmetric'
            -  one of the {'zero', 'constant', 'symmetric', 'periodic',
                'smooth', 'periodization'}
    
        wpd_maxlevel: int, defualt=None
            - maximum number of levels for decomposition,
            - if None, max possible number of level are used.
    
        use_joblib: bool, default=False
            -  If True, joblib is used for parallel processing of the channels
    
        verbose: int
           -  vebosity level
    
    
        Experimental Settings
    
            .. note:: NOT RECOMMONEDED TO CHANGE
                Following parameters are experimental,
                they are not recommonded to change, and leave as default
    
        WPD: bool, default=True
           - if False Wavelet Transform is used for decompisiton of signal,
             else Wavelet Packet Decomposition is used
    
        packetwise: bool, deafult=False
           -  if True, threshold is computed and applied to each packet independently. 
    
        lvl: list defualt=[]
           -  if provided, ATAR is applied to provided level numbers only.
     
        recons_method: str deafult='atar-style'
           - reconstruction method after applying atar to each window.
           - one of {'atar-style', 'atar', 'custom', 'HamWin','Hamming'}
    
           .. note:: NOT RECOMMONEDED TO CHANGE
              KEEP IT TO DEFAULT
    
    
        window: list of two default=['hamming',True]
            -  window function, and if windowing is applied before or after atar
    
    
        Returns
        -------
        XR: corrected signal of same shape as input X
    
    
        References
        ----------
        .. [1] Bajaj, Nikesh, et al. "Automatic and tunable algorithm for EEG artifact removal using wavelet decomposition with applications in predictive modeling during auditory tasks." Biomedical Signal Processing and Control 55 (2020): 101624. https://doi.org/10.1016/j.bspc.2019.101624
    
    
    
    
        See Also
        --------
        ATAR_1Ch: ATAR for single channel
        ATAR_mCh: ATAR for multiple channel
        ICA_filtering: ICA based Artifact Removal Algorithm
    
    
        Examples
        --------
        #sp.eeg.ATAR
        import numpy as np
        import matplotlib.pyplot as plt
        import spkit as sp
        X,fs, ch_names = sp.data.eeg_sample_14ch()
        X = sp.filterDC_sGolay(X, window_length=fs//3+1)
        t = np.arange(X.shape[0])/fs
        # Single Channel
        x = X[:,0] 
        xc1 = sp.eeg.ATAR(x,wv='db3', winsize=128, thr_method='ipr',beta=0.1, k1=10, k2=100,OptMode='soft',verbose=1)
        xc2 = sp.eeg.ATAR(x,wv='db3', winsize=128, thr_method='ipr',beta=0.1, k1=10, k2=100,OptMode='linAtten',verbose=1)
        xc3 = sp.eeg.ATAR(x,wv='db3', winsize=128, thr_method='ipr',beta=0.1, k1=10, k2=100,OptMode='elim',verbose=1)
        # Multi-Channel
        Xc = sp.eeg.ATAR(X,wv='db3', winsize=128, thr_method='ipr',beta=0.2, k1=10, k2=100,OptMode='elim')
        sep=200
        plt.figure(figsize=(10,6))
        plt.subplot(211)
        plt.plot(t,x, label='$x$: raw EEG - single channel')
        plt.plot(t,xc1,label=r'$x_{c1}$: Soft Thresholding')
        plt.plot(t,xc2,label=r'$x_{c2}$: Linear Attenuation')
        plt.plot(t,xc3,label=r'$x_{c3}$: Elimination')
        plt.xlim([9,12])
        plt.ylim([-200,200])
        plt.legend(bbox_to_anchor=(0.5,0.99),ncol=2,fontsize=8)
        plt.grid()
        plt.title(r'ATAR Algorithm')
        plt.xlabel('time (s)')
        plt.subplot(223)
        plt.plot(t,X+np.arange(X.shape[1])*sep)
        plt.xlim([t[0],t[-1]])
        plt.yticks(np.arange(X.shape[1])*sep,ch_names)
        plt.title(r'$X$: EEG')
        plt.xlabel('time (s)')
        plt.subplot(224)
        plt.plot(t,Xc+np.arange(14)*sep)
        plt.xlim([t[0],t[-1]])
        plt.title(r'$X_c$: ATAR (Elimination Mode)')
        plt.yticks(np.arange(X.shape[1])*sep,ch_names)
        plt.xlabel('time (s)')
        plt.tight_layout()
        plt.show()

    Help on function ATAR_1Ch in module spkit.eeg.atar_algorithm:

    ATAR_1Ch(x, wv='db3', winsize=128, thr_method='ipr', OptMode='soft', IPR=[25, 75], beta=0.1, k1=None, k2=100, est_wmax=100, theta_a=inf, bf=2, gf=0.8, wpd_mode='symmetric', wpd_maxlevel=None, recons_method='atar-style', window=['hamming', True], hopesize=None, packetwise=False, WPD=True, lvl=[], verbose=False, **kwargs)
        ATAR : Automatic and Tunable Artifact Removal Algorithm (single channel)
    
        .. raw:: html
    
            <h2 style="text-align:center">ATAR: - Automatic and Tunable Artifact Removal Algorithm :  Single Channel</h2>
    
        Apply ATAR on short windows of signal (single channel):
    
        Signal is decomposed in smaller overlapping windows and reconstructed after correcting using overlap-add method.
    
        For more details, check [1]_
    
        **Operating Modes**
    
        **1. Soft Thresholding**
    
        .. math ::
    
           \lambda_s (w)  &=  w  & \quad \text{if } |w|<\theta_{\gamma}
    
              &=  \theta_{\alpha} \frac{1 - e^{\alpha w}}{1 + e^{\alpha w}}   & \quad \text{otherwise}
    
    
        **2. Elimination**
    
        .. math ::
    
           \lambda_e (w)  &=  w  & \quad \text{if } |w| \le \theta_{\alpha}
    
             &=  0   & \quad \text{otherwise}
    
    
        **3. Linear Attenuation**
    
        .. math ::
    
           \lambda_a (w)  &=  w  & \quad \text{if } |w| \le \theta_{\alpha}
    
                  &=  sgn(w) \theta_{\alpha} \Big( 1 -  \frac{|w| - \theta_{\alpha}}{\theta_{\beta}-\theta_{\alpha}} \Big) & \quad \text{if } \theta_{\alpha} < |w| \le \theta_{\beta}
              
                  &=  0   & \quad \text{otherwise}
    
    
        **Computing Threshold**
    
        * :math:`f_{\beta}(r)  = k_2 \cdot exp \Big(-\beta \frac{w_{max}}{k_2} \times \frac{r}{2} \Big)`
    
        * :math:`\theta_{\alpha}  =  f_{\beta}(r)  \quad \text{if } f_{\beta}(r) \ge k_1` otherwise :math:`\theta_{\alpha}  =  k_1`
    
        * :math:`\theta_{\gamma}  = g_f \times \theta_{\alpha}` ,  where a default value for 'g_f = 0.8' **For Soft-threshold**
    
        * :math:`\theta_{\beta}  = b_f \times \theta_{\alpha}` , where a default value for 'b_f = 2' **For Linear Attenuation**
    
    
    
    
        ..
            _wfilter(x,wv='db3',thr_method='ipr',IPR=[25,75],beta=0.1,k1=10,k2=100,theta_a=np.inf,est_wmax=100,
                bf=2,gf=0.8,OptMode ='soft',factor=1.0,show_plot=False,wpd_mode='symmetric',wpd_maxlevel=None,
                WPD=True,packetwise=False,lvl=[],fs=128.0,verbose=0)
    
        Parameters
        ----------
        x : 1d-array
          - input single-channel signal of shape (n,)
    
        wv = str, 'db3'(default) wavelet
          - one of wavelet family {'db3'.....'db38', 'sym2.....sym20', 
                         'coif1.....coif17', 'bior1.1....bior6.8', 
                        'rbio1.1...rbio6.8', 'dmey'}
    
        winsize: int, deafult=128
           -  window size to apply ATAR
    
        hopesize: int, None, default=None,
           - overlap shift for next window
           - if None, hopesize=winsize//2
           - only used when recons_method={'atar-style','atar','custom'}
    
    
        Operating modes
    
        OptMode: str, {'soft','elim','linAtten'}, default 'soft'
            - Operating Modes:
            - soft: soft-thresholding (need theta_a, and theta_g)
            - elim: Elimination mode  (need theta_a)
            - linAtten: Linear Attenuation mode (need theta_a and theta_b)
                - given `bf` and `gf` (default bf = 2, gf=0.8)
                -  where:-
                    * theta_b = bf*theta_a  -- used for Linear Attenuation
                    * theta_g = gf*theta_a  -- used for Soft thresholding
    
        *Threshold Computation method*
    
        thr_method: str, {'ipr', None}
            - Computing method for threshold
            - if 'ipr'  'theta_a' is computed as per ATAR's approach
            - if None, passed value of 'theta_a' is used along with (bf, gf)
    
        IPR: list of two default=[25,75]
           - To compute Interpercentile range r
           - e.g. [10,90], [30,70]
           - Higher the range is, threshold is more affected by outliers
           - Interpercentile range r is mapped to threshold, using `beta`, `k1` and `k2`
    
        beta: float (0,1] default=0.1
           - beta as tuning parameter for threshold
           - higher the value, more aggressive is the algorithm to remove artifacts
    
        (k1,k2) :scalars, defualt (10,100)
           - lower and upper bounds on the threshold value
           - should be of same order as signal magnitude.
           - if signal is in volts, values will be of order 1e-6, then k1 and k2 should be around those order
           - defult values k1=10, k2=100 are chosen for signal with unit of microVolt (uV), of order of 100s
       
    
           .. warning:: k1,k2 bounds
              if k2 is very high (e.g. 100) and signal amplitude is in 1e-3, 1e-6, 
              ATAR will have no effect on the signal, as theshold to identify and remove artifacts will be so high.
    
    
        est_wmax: int, default=100
            - est_wmax is the value in the expression (15 in paper) or above Computing Threshold equations `w_max`
    
    
        *Wavelet Decomposition*
    
        wpd_mode: str,  default 'symmetric'
            -  one of the {'zero', 'constant', 'symmetric', 'periodic',
                'smooth', 'periodization'}
    
        wpd_maxlevel: int, defualt=None
            - maximum number of levels for decomposition,
            - if None, max possible number of level are used.
    
        verbose: int
           - verbosity mode
    
        Experimental Settings
    
            .. note:: NOT RECOMMONEDED TO CHANGE
                Following parameters are experimental,
                they are not recommonded to change, and leave as default
    
        WPD: bool, default=True
           - if False Wavelet Transform is used for decompisiton of signal,
             else Wavelet Packet Decomposition is used
    
        packetwise: bool, deafult=False
           -  if True, threshold is computed and applied to each packet independently. 
    
        lvl: list defualt=[]
           -  if provided, ATAR is applied to provided level numbers only.
     
        recons_method: str deafult='atar-style'
           - reconstruction method after applying atar to each window.
           - one of {'atar-style', 'atar', 'custom', 'HamWin','Hamming'}
    
           .. note:: NOT RECOMMONEDED TO CHANGE
              KEEP IT TO DEFAULT
    
    
        window: list of two default=['hamming',True]
            -  window function, and if windowing is applied before or after atar
    
    
       
        Returns
        -------
        XR: corrected signal of same shape as input X
    
        Reference
        ---------
        .. [1] Bajaj, Nikesh, et al. "Automatic and tunable algorithm for EEG artifact removal using wavelet decomposition with applications in predictive modeling during auditory tasks." Biomedical Signal Processing and Control 55 (2020): 101624. https://doi.org/10.1016/j.bspc.2019.101624 
    
    
        See Also
        --------
        ATAR: Automatic and Tuanable Artifact Removal Algorithm
        ATAR_mCh: ATAR for multiple channel
        ICA_filtering: ICA based Artifact Removal Algorithm
    
    
        Examples
        --------
        #sp.eeg.ATAR_1Ch
        import numpy as np
        import matplotlib.pyplot as plt
        import spkit as sp
        X,fs, ch_names = sp.data.eeg_sample_14ch()
        X = sp.filterDC_sGolay(X, window_length=fs//3+1)
        t = np.arange(X.shape[0])/fs
        # Single Channel
        x = X[:,0] 
        xc1 = sp.eeg.ATAR_1Ch(x,wv='db3', winsize=128, thr_method='ipr',beta=0.1, k1=10, k2=100,OptMode='soft',verbose=1)
        xc2 = sp.eeg.ATAR_1Ch(x,wv='db3', winsize=128, thr_method='ipr',beta=0.1, k1=10, k2=100,OptMode='linAtten',verbose=1)
        xc3 = sp.eeg.ATAR_1Ch(x,wv='db3', winsize=128, thr_method='ipr',beta=0.1, k1=10, k2=100,OptMode='elim',verbose=1)
        plt.figure(figsize=(10,6))
        plt.subplot(211)
        plt.plot(t,x, label='$x$: raw EEG - single channel')
        plt.plot(t,xc1,label=r'$x_{c1}$: Soft Thresholding')
        plt.plot(t,xc2,label=r'$x_{c2}$: Linear Attenuation')
        plt.plot(t,xc3,label=r'$x_{c3}$: Elimination')
        #plt.xlim([9,12])
        #plt.ylim([-200,200])
        plt.legend(bbox_to_anchor=(0.5,0.99),ncol=2,fontsize=8)
        plt.grid()
        plt.title(r'ATAR Algorithm')
        plt.subplot(212)
        plt.plot(t,x, label='$x$: raw EEG - single channel')
        plt.plot(t,xc1,label=r'$x_{c1}$: Soft Thresholding')
        plt.plot(t,xc2,label=r'$x_{c2}$: Linear Attenuation')
        plt.plot(t,xc3,label=r'$x_{c3}$: Elimination')
        plt.xlim([9,12])
        plt.ylim([-200,200])
        plt.legend(bbox_to_anchor=(0.5,0.99),ncol=2,fontsize=8)
        plt.grid()
        plt.title(r'ATAR Algorithm')
        plt.xlabel('time (s)')
        plt.tight_layout()
        plt.show()

    Help on function ATAR_mCh in module spkit.eeg.atar_algorithm:

    ATAR_mCh(X, wv='db3', winsize=128, thr_method='ipr', OptMode='elim', IPR=[25, 75], beta=0.1, k1=10, k2=100, est_wmax=100, theta_a=inf, bf=2, gf=0.8, wpd_mode='symmetric', wpd_maxlevel=None, verbose=False, window=['hamming', True], hopesize=None, recons_method='atar-style', packetwise=False, WPD=True, lvl=[], use_joblib=False, **kwargs)
        ATAR: - Automatic and Tunable Artifact Removal Algorithm
    
        .. raw:: html
    
            <h2 style="text-align:center">ATAR: - Automatic and Tunable Artifact Removal Algorithm: Multi-channels</h2>
    
        Apply ATAR on short windows of signal
    
        Signal is decomposed in smaller overlapping windows and reconstructed after correcting using overlap-add method.
    
        For more details, check [1]_
    
        **Operating Modes**
    
        **1. Soft Thresholding**
    
        .. math ::
    
           \lambda_s (w)  &=  w  & \quad \text{if } |w|<\theta_{\gamma}
    
              &=  \theta_{\alpha} \frac{1 - e^{\alpha w}}{1 + e^{\alpha w}}   & \quad \text{otherwise}
    
    
        **2. Elimination**
    
        .. math ::
    
           \lambda_e (w)  &=  w  & \quad \text{if } |w| \le \theta_{\alpha}
    
             &=  0   & \quad \text{otherwise}
    
    
        **3. Linear Attenuation**
    
        .. math ::
    
           \lambda_a (w)  &=  w  & \quad \text{if } |w| \le \theta_{\alpha}
    
                  &=  sgn(w) \theta_{\alpha} \Big( 1 -  \frac{|w| - \theta_{\alpha}}{\theta_{\beta}-\theta_{\alpha}} \Big) & \quad \text{if } \theta_{\alpha} < |w| \le \theta_{\beta}
              
                  &=  0   & \quad \text{otherwise}
    
    
        **Computing Threshold**
    
        * :math:`f_{\beta}(r)  = k_2 \cdot exp \Big(-\beta \frac{w_{max}}{k_2} \times \frac{r}{2} \Big)`
    
        * :math:`\theta_{\alpha}  =  f_{\beta}(r)  \quad \text{if } f_{\beta}(r) \ge k_1` otherwise :math:`\theta_{\alpha}  =  k_1`
    
        * :math:`\theta_{\gamma}  = g_f \times \theta_{\alpha}` ,  where a default value for 'g_f = 0.8' **For Soft-threshold**
    
        * :math:`\theta_{\beta}  = b_f \times \theta_{\alpha}` , where a default value for 'b_f = 2' **For Linear Attenuation**
    
    
        Parameters
        ----------
        x : 1d-array
          - input single-channel signal of shape (n,)
    
        wv = str, 'db3'(default) wavelet
          - one of wavelet family {'db3'.....'db38', 'sym2.....sym20', 
                         'coif1.....coif17', 'bior1.1....bior6.8', 
                        'rbio1.1...rbio6.8', 'dmey'}
    
        winsize: int, deafult=128
           -  window size to apply ATAR
    
        hopesize: int, None, default=None,
           - overlap shift for next window
           - if None, hopesize=winsize//2
           - only used when recons_method={'atar-style','atar','custom'}
    
    
        Operating modes
    
        OptMode: str, {'soft','elim','linAtten'}, default 'soft'
            - Operating Modes:
            - soft: soft-thresholding (need theta_a, and theta_g)
            - elim: Elimination mode  (need theta_a)
            - linAtten: Linear Attenuation mode (need theta_a and theta_b)
                - given `bf` and `gf` (default bf = 2, gf=0.8)
                -  where:-
                    * theta_b = bf*theta_a  -- used for Linear Attenuation
                    * theta_g = gf*theta_a  -- used for Soft thresholding
    
        *Threshold Computation method*
    
        thr_method: str, {'ipr', None}
            - Computing method for threshold
            - if 'ipr'  'theta_a' is computed as per ATAR's approach
            - if None, passed value of 'theta_a' is used along with (bf, gf)
    
        IPR: list of two default=[25,75]
           - To compute Interpercentile range r
           - e.g. [10,90], [30,70]
           - Higher the range is, threshold is more affected by outliers
           - Interpercentile range r is mapped to threshold, using `beta`, `k1` and `k2`
    
        beta: float (0,1] default=0.1
           - beta as tuning parameter for threshold
           - higher the value, more aggressive is the algorithm to remove artifacts
    
        (k1,k2) :scalars, defualt (10,100)
           - lower and upper bounds on the threshold value
           - should be of same order as signal magnitude.
           - if signal is in volts, values will be of order 1e-6, then k1 and k2 should be around those order
           - defult values k1=10, k2=100 are chosen for signal with unit of microVolt (uV), of order of 100s
       
    
           .. warning:: k1,k2 bounds
              if k2 is very high (e.g. 100) and signal amplitude is in 1e-3, 1e-6, 
              ATAR will have no effect on the signal, as theshold to identify and remove artifacts will be so high.
    
    
        est_wmax: int, default=100
            - est_wmax is the value in the expression (15 in paper) or above Computing Threshold equations `w_max`
    
    
        *Wavelet Decomposition*
    
        wpd_mode: str,  default 'symmetric'
            -  one of the {'zero', 'constant', 'symmetric', 'periodic',
                'smooth', 'periodization'}
    
        wpd_maxlevel: int, defualt=None
            - maximum number of levels for decomposition,
            - if None, max possible number of level are used.
    
        use_joblib: bool, default=False
            -  If True, joblib is used for parallel processing of the channels
    
        verbose: int
           - verbosity mode
    
        Experimental Settings
    
            .. note:: NOT RECOMMONEDED TO CHANGE
                Following parameters are experimental,
                they are not recommonded to change, and leave as default
    
        WPD: bool, default=True
           - if False Wavelet Transform is used for decompisiton of signal,
             else Wavelet Packet Decomposition is used
    
        packetwise: bool, deafult=False
           -  if True, threshold is computed and applied to each packet independently. 
    
        lvl: list defualt=[]
           -  if provided, ATAR is applied to provided level numbers only.
     
        recons_method: str deafult='atar-style'
           - reconstruction method after applying atar to each window.
           - one of {'atar-style', 'atar', 'custom', 'HamWin','Hamming'}
    
           .. note:: NOT RECOMMONEDED TO CHANGE
              KEEP IT TO DEFAULT
    
    
        window: list of two default=['hamming',True]
            -  window function, and if windowing is applied before or after atar
    
        Returns
        -------
        XR: corrected signal of same shape as input X
    
    
        References
        ----------
        .. [1] Bajaj, Nikesh, et al. "Automatic and tunable algorithm for EEG artifact removal using wavelet decomposition with applications in predictive modeling during auditory tasks." Biomedical Signal Processing and Control 55 (2020): 101624. https://doi.org/10.1016/j.bspc.2019.101624
    
    
    
        See Also
        --------
        ATAR: Automatic and Tuanable Artifact Removal Algorithm
        ATAR_1Ch: ATAR for single channel
        ICA_filtering: ICA based Artifact Removal Algorithm
    
        Examples
        --------
        #sp.eeg.ATAR_mCh
        import numpy as np
        import matplotlib.pyplot as plt
        import spkit as sp
        X,fs, ch_names = sp.data.eeg_sample_14ch()
        X = sp.filterDC_sGolay(X, window_length=fs//3+1)
        t = np.arange(X.shape[0])/fs
        # Multi-Channel
        Xc = sp.eeg.ATAR_mCh(X,wv='db3', winsize=128, thr_method='ipr',beta=0.2, k1=10, k2=100,OptMode='elim',verbose=1)
        sep=200
        plt.figure(figsize=(10,6))
        plt.subplot(211)
        plt.plot(t,x, label='$x$: raw EEG - single channel')
        plt.plot(t,xc1,label=r'$x_{c1}$: Soft Thresholding')
        plt.plot(t,xc2,label=r'$x_{c2}$: Linear Attenuation')
        plt.plot(t,xc3,label=r'$x_{c3}$: Elimination')
        plt.xlim([9,12])
        plt.ylim([-200,200])
        plt.legend(bbox_to_anchor=(0.5,0.99),ncol=2,fontsize=8)
        plt.grid()
        plt.title(r'ATAR Algorithm')
        plt.xlabel('time (s)')
        plt.subplot(223)
        plt.plot(t,X+np.arange(X.shape[1])*sep)
        plt.xlim([t[0],t[-1]])
        plt.yticks(np.arange(X.shape[1])*sep,ch_names)
        plt.title(r'$X$: EEG')
        plt.xlabel('time (s)')
        plt.subplot(224)
        plt.plot(t,Xc+np.arange(14)*sep)
        plt.xlim([t[0],t[-1]])
        plt.title(r'$X_c$: ATAR (Elimination Mode)')
        plt.yticks(np.arange(X.shape[1])*sep,ch_names)
        plt.xlabel('time (s)')
        plt.tight_layout()
        plt.show()







|

.. code-block:: Python

    # In[2]:


    import numpy as np
    import matplotlib.pyplot as plt
    import warnings
    warnings.filterwarnings("ignore")

    import spkit as sp
    sp.__version__


    # # Import EEG sample data

    # In[3]:


    X,ch_names = sp.load_data.eegSample()
    fs = 128


    # In[4]:


    #help(sp.filter_X)


    # ## Filter with highpass

    # In[5]:


    Xf = sp.filter_X(X,band=[0.5], btype='highpass',fs=fs,verbose=0)
    Xf.shape


    # In[6]:


    t = np.arange(Xf.shape[0])/fs
    plt.figure(figsize=(12,5))
    plt.plot(t,Xf+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf: 14 channel - EEG Signal (filtered)')
    plt.show()


    # # Applying ATAR Algorithm 

    # ## Soft Thresholding: default settings: OptMode='soft' and $\beta=0.1$

    # In[18]:


    XR = sp.eeg.ATAR(Xf.copy(),verbose=0)
    XR.shape


    # In[19]:


    plt.figure(figsize=(12,5))
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal')
    plt.show()

    plt.figure(figsize=(12,5))
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Linear Attenuation

    # In[20]:


    XR = sp.eeg.ATAR(Xf.copy(),verbose=0,OptMode='linAtten')
    XR.shape


    # In[21]:


    plt.figure(figsize=(12,5))
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal')
    plt.show()

    plt.figure(figsize=(12,5))
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Elimination

    # In[22]:


    XR = sp.eeg.ATAR(Xf.copy(),verbose=0,OptMode='elim')
    XR.shape


    # In[23]:


    plt.figure(figsize=(12,5))
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal')
    plt.show()

    plt.figure(figsize=(12,5))
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Tuning $\beta$ with 'soft' : Controlling the aggressiveness

    # In[24]:


    betas = np.r_[np.arange(0.01,0.1,0.02), np.arange(0.1,1, 0.1)].round(2)

    for b in betas:
        XR = sp.eeg.ATAR(Xf.copy(),verbose=0,beta=b,OptMode='soft')
        XR.shape

        plt.figure(figsize=(15,5))
        plt.subplot(121)
        plt.plot(t,XR+np.arange(-7,7)*200)
        plt.xlim([t[0],t[-1]])
        plt.xlabel('time (sec)')
        plt.yticks(np.arange(-7,7)*200,ch_names)
        plt.grid()
        plt.title('XR: Corrected Signal: '+r'$\beta=$' + f'{b}')
    
        plt.subplot(122)
        plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
        plt.xlim([t[0],t[-1]])
        plt.xlabel('time (sec)')
        plt.yticks(np.arange(-7,7)*200,ch_names)
        plt.grid()
        plt.title('Xf - XR: Difference (removed signal)')
        plt.show()


    # ## Tuning $\beta$ with 'elim'

    # In[25]:


    betas = np.r_[np.arange(0.01,0.1,0.02), np.arange(0.1,1, 0.1)].round(2)

    for b in betas:
        XR = sp.eeg.ATAR(Xf.copy(),verbose=0,beta=b,OptMode='elim')
        XR.shape

        plt.figure(figsize=(15,5))
        plt.subplot(121)
        plt.plot(t,XR+np.arange(-7,7)*200)
        plt.xlim([t[0],t[-1]])
        plt.xlabel('time (sec)')
        plt.yticks(np.arange(-7,7)*200,ch_names)
        plt.grid()
        plt.title('XR: Corrected Signal: '+r'$\beta=$' + f'{b}')
    
        plt.subplot(122)
        plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
        plt.xlim([t[0],t[-1]])
        plt.xlabel('time (sec)')
        plt.yticks(np.arange(-7,7)*200,ch_names)
        plt.grid()
        plt.title('Xf - XR: Difference (removed signal)')
        plt.show()


    # # Other settings
    # ## Changing wavelet function

    # In[26]:


    XR = sp.eeg.ATAR(Xf.copy(),wv='db8',beta=0.01,OptMode='elim',verbose=0,)
    XR.shape

    plt.figure(figsize=(15,5))
    plt.subplot(121)
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal: '+r'$wv=db8$')

    plt.subplot(122)
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    XR = sp.eeg.ATAR_mCh_noParallel(Xf.copy(),wv='db32',beta=0.01,OptMode='elim',verbose=0,)
    XR.shape

    plt.figure(figsize=(15,5))
    plt.subplot(121)
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal: '+r'$wv=db32$')

    plt.subplot(122)
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Changing upper and lower bounds: $k_1$, $k_2$

    # $k_1$ and $k_2$ are lower and upper bound on the threshold $\theta_\alpha$. $k_1$ is set to 10, which means, the lowest threshold value will be 10, this helps to prevent the removal of entire signal (zeroing out) due to present of high magnitute of artifact. $k_2$ is largest threshold value, which in terms set the decaying curve of threshold $\theta_\alpha$. Increasing k2 will make the removal less aggressive

    # In[27]:


    XR = sp.eeg.ATAR(Xf.copy(),wv='db3',beta=0.1,OptMode='elim',verbose=0,k1=10, k2=200)
    XR.shape

    plt.figure(figsize=(15,5))
    plt.subplot(121)
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal: '+r'$k_2=200$')

    plt.subplot(122)
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Changing IPR -  Interpercentile range

    # **IPR is interpercentile range**, which is set to 50% (IPR=[25,75]) as default (inter-quartile range), incresing the range increses the aggressiveness of removing artifacts. 

    # In[28]:


    XR = sp.eeg.ATAR(Xf.copy(),wv='db3',beta=0.1,OptMode='elim',verbose=0,k1=10, k2=200, IPR=[15,85])

    plt.figure(figsize=(15,5))
    plt.subplot(121)
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal: '+r'$IPR=[15,85]$~ 70%')

    plt.subplot(122)
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Using the fix threshold $\theta_\alpha=300$,  to all the windows

    # In[29]:


    XR = sp.eeg.ATAR(Xf.copy(),wv='db3',thr_method=None,theta_a=300,OptMode='elim',verbose=0)

    plt.figure(figsize=(15,5))
    plt.subplot(121)
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal: '+r'$\theta_\alpha=300$')

    plt.subplot(122)
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # ## Changing window length (5 sec)

    # **winsize** is be default set to 128 (1 sec), assuming 128 sampling rate, which can be changed as needed. In following example it is changed to 5 sec.

    # In[31]:


    XR = sp.eeg.ATAR(Xf.copy(),winsize=128*5,beta=0.01,OptMode='elim',verbose=0,)

    plt.figure(figsize=(15,5))
    plt.subplot(121)
    plt.plot(t,XR+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('XR: Corrected Signal: '+r'$winsize=5sec$')

    plt.subplot(122)
    plt.plot(t,(Xf-XR)+np.arange(-7,7)*200)
    plt.xlim([t[0],t[-1]])
    plt.xlabel('time (sec)')
    plt.yticks(np.arange(-7,7)*200,ch_names)
    plt.grid()
    plt.title('Xf - XR: Difference (removed signal)')
    plt.show()


    # # Doc

    # In[32]:


    help(sp.eeg.ATAR)


    # In[35]:


    help(sp.eeg.ATAR_1Ch)


    # In[34]:


    help(sp.eeg.ATAR_mCh)


    # In[ ]:






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 14.056 seconds)


.. _sphx_glr_download_auto_examples_signal_processing_plot_sp_ATAR_algorithm_eeg_artifact_removal.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/spkit/spkit/0.9.X?urlpath=lab/tree/notebooks/auto_examples/signal_processing/plot_sp_ATAR_algorithm_eeg_artifact_removal.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: lite-badge

      .. image:: images/jupyterlite_badge_logo.svg
        :target: ../../lite/lab/?path=auto_examples/signal_processing/plot_sp_ATAR_algorithm_eeg_artifact_removal.ipynb
        :alt: Launch JupyterLite
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_sp_ATAR_algorithm_eeg_artifact_removal.ipynb <plot_sp_ATAR_algorithm_eeg_artifact_removal.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_sp_ATAR_algorithm_eeg_artifact_removal.py <plot_sp_ATAR_algorithm_eeg_artifact_removal.py>`


.. include:: plot_sp_ATAR_algorithm_eeg_artifact_removal.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
